# 表单校验业务场景文档

## 前言

表单校验是前端开发中的重要环节，不同的业务场景需要不同的校验策略。本文档列举了多种常见的表单校验业务场景及其实现思路，可作为开发参考。

## 一、基础校验场景

### 1. 必填项校验

**应用场景**：几乎所有表单都会有必填项，如用户注册时的用户名、密码等。

**实现思路**：
- 使用 `required: true` 配置必填规则
- 可自定义错误提示信息

```jsx
<Form.Item
  name="username"
  label="用户名"
  rules={[{ required: true, message: '请输入用户名！' }]}
>
  <Input />
</Form.Item>
```

### 2. 格式校验

**应用场景**：输入内容需符合特定格式，如邮箱、手机号、URL等。

**实现思路**：
- 使用内置的 `type` 属性进行校验
- 或使用 `pattern` 属性配合正则表达式进行自定义校验

```jsx
<Form.Item
  name="email"
  label="邮箱"
  rules={[
    { required: true, message: '请输入邮箱！' },
    { type: 'email', message: '请输入有效的邮箱地址！' }
  ]}
>
  <Input />
</Form.Item>

<Form.Item
  name="phone"
  label="手机号"
  rules={[
    { required: true, message: '请输入手机号！' },
    { pattern: /^1[3-9]\d{9}$/, message: '请输入有效的手机号码！' }
  ]}
>
  <Input />
</Form.Item>
```

### 3. 长度/范围校验

**应用场景**：限制输入内容的长度或数值范围，如密码长度、年龄范围等。

**实现思路**：
- 使用 `min`、`max`、`len` 属性进行长度校验
- 对于数值类型，可使用 `min`、`max` 限制范围

```jsx
<Form.Item
  name="password"
  label="密码"
  rules={[
    { required: true, message: '请输入密码！' },
    { min: 6, message: '密码长度不能少于6位！' },
    { max: 20, message: '密码长度不能超过20位！' }
  ]}
>
  <Input.Password />
</Form.Item>

<Form.Item
  name="age"
  label="年龄"
  rules={[
    { required: true, message: '请输入年龄！' },
    { type: 'number', min: 18, message: '年龄必须大于等于18岁！' },
    { type: 'number', max: 100, message: '年龄必须小于等于100岁！' }
  ]}
>
  <InputNumber />
</Form.Item>
```

### 4. 自定义校验函数

**应用场景**：复杂的校验逻辑，如密码强度校验、特定业务规则校验等。

**实现思路**：
- 使用 `validator` 函数进行自定义校验
- 返回 `Promise.resolve()` 表示校验通过，返回 `Promise.reject(new Error('错误信息'))` 表示校验失败

```jsx
<Form.Item
  name="password"
  label="密码"
  rules={[
    { required: true, message: '请输入密码！' },
    {
      validator: (_, value) => {
        if (!value) {
          return Promise.resolve();
        }
        const hasUpperCase = /[A-Z]/.test(value);
        const hasLowerCase = /[a-z]/.test(value);
        const hasNumber = /\d/.test(value);
        const hasSpecialChar = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(value);
        
        if (value.length < 8) {
          return Promise.reject(new Error('密码长度不能少于8位！'));
        }
        
        if (!(hasUpperCase && hasLowerCase && hasNumber && hasSpecialChar)) {
          return Promise.reject(new Error('密码必须包含大小写字母、数字和特殊字符！'));
        }
        
        return Promise.resolve();
      }
    }
  ]}
>
  <Input.Password />
</Form.Item>
```

## 二、嵌套表单校验场景

### 1. 对象嵌套校验

**应用场景**：表单中包含对象类型的字段，如用户地址信息（包含省、市、区、详细地址等）。

**实现思路**：
- 使用 `Form.Item` 的嵌套结构
- 外层 `Form.Item` 不设置 `name` 属性，仅用于布局
- 内层 `Form.Item` 设置 `name` 属性，形成对象的属性名

```jsx
<Form.Item label="地址信息">
  <Input.Group compact>
    <Form.Item
      name={['address', 'province']}
      noStyle
      rules={[{ required: true, message: '请选择省份！' }]}
    >
      <Select placeholder="选择省份" style={{ width: '30%' }}>
        {/* 省份选项 */}
      </Select>
    </Form.Item>
    <Form.Item
      name={['address', 'city']}
      noStyle
      rules={[{ required: true, message: '请选择城市！' }]}
    >
      <Select placeholder="选择城市" style={{ width: '30%' }}>
        {/* 城市选项 */}
      </Select>
    </Form.Item>
    <Form.Item
      name={['address', 'detail']}
      noStyle
      rules={[{ required: true, message: '请输入详细地址！' }]}
    >
      <Input placeholder="详细地址" style={{ width: '40%' }} />
    </Form.Item>
  </Input.Group>
</Form.Item>
```

### 2. 动态嵌套表单

**应用场景**：表单中包含可动态增减的嵌套表单项，如多个联系人信息。

**实现思路**：
- 使用 `Form.List` 组件实现动态表单
- 结合 `add`、`remove` 方法实现增减操作

```jsx
<Form.List name="contacts">
  {(fields, { add, remove }) => (
    <>
      {fields.map(({ key, name, ...restField }) => (
        <div key={key} style={{ display: 'flex', marginBottom: 8 }}>
          <Form.Item
            {...restField}
            name={[name, 'name']}
            rules={[{ required: true, message: '请输入联系人姓名！' }]}
          >
            <Input placeholder="联系人姓名" />
          </Form.Item>
          <Form.Item
            {...restField}
            name={[name, 'phone']}
            rules={[
              { required: true, message: '请输入联系电话！' },
              { pattern: /^1[3-9]\d{9}$/, message: '请输入有效的手机号码！' }
            ]}
          >
            <Input placeholder="联系电话" />
          </Form.Item>
          <Button onClick={() => remove(name)} type="text" danger>
            删除
          </Button>
        </div>
      ))}
      <Form.Item>
        <Button type="dashed" onClick={() => add()} block>
          添加联系人
        </Button>
      </Form.Item>
    </>
  )}
</Form.List>
```

## 三、循环列表校验场景

### 1. 表格表单校验

**应用场景**：在表格中进行表单编辑和校验，如商品列表编辑、批量数据录入等。

**实现思路**：
- 结合 `Table` 组件和 `Form` 组件
- 使用 `Form.List` 管理表格数据
- 每行数据对应一个嵌套的表单项

```jsx
<Form.List name="products">
  {(fields) => (
    <Table
      dataSource={fields.map(field => ({ ...field, key: field.key }))}
      columns={[
        {
          title: '商品名称',
          dataIndex: 'name',
          render: (_, record) => (
            <Form.Item
              name={[record.name, 'productName']}
              rules={[{ required: true, message: '请输入商品名称！' }]}
            >
              <Input />
            </Form.Item>
          ),
        },
        {
          title: '单价',
          dataIndex: 'price',
          render: (_, record) => (
            <Form.Item
              name={[record.name, 'price']}
              rules={[
                { required: true, message: '请输入单价！' },
                { type: 'number', min: 0, message: '单价不能为负数！' }
              ]}
            >
              <InputNumber min={0} />
            </Form.Item>
          ),
        },
        {
          title: '数量',
          dataIndex: 'quantity',
          render: (_, record) => (
            <Form.Item
              name={[record.name, 'quantity']}
              rules={[
                { required: true, message: '请输入数量！' },
                { type: 'number', min: 1, message: '数量必须大于0！' }
              ]}
            >
              <InputNumber min={1} />
            </Form.Item>
          ),
        },
      ]}
      pagination={false}
    />
  )}
</Form.List>
```

### 2. 动态增减表单项

**应用场景**：允许用户动态添加或删除表单项，如添加多个技能、教育经历等。

**实现思路**：
- 使用 `Form.List` 实现动态表单
- 提供添加和删除按钮
- 对每个表单项进行独立校验

```jsx
<Form.List name="skills">
  {(fields, { add, remove }) => (
    <>
      {fields.map(({ key, name, ...restField }) => (
        <Space key={key} style={{ display: 'flex', marginBottom: 8 }} align="baseline">
          <Form.Item
            {...restField}
            name={[name, 'name']}
            rules={[{ required: true, message: '请输入技能名称！' }]}
          >
            <Input placeholder="技能名称" />
          </Form.Item>
          <Form.Item
            {...restField}
            name={[name, 'level']}
            rules={[{ required: true, message: '请选择熟练度！' }]}
          >
            <Select placeholder="熟练度" style={{ width: 120 }}>
              <Option value="beginner">入门</Option>
              <Option value="intermediate">中级</Option>
              <Option value="advanced">高级</Option>
              <Option value="expert">专家</Option>
            </Select>
          </Form.Item>
          <Button onClick={() => remove(name)} type="text" danger>
            删除
          </Button>
        </Space>
      ))}
      <Form.Item>
        <Button type="dashed" onClick={() => add()} block icon={<PlusOutlined />}>
          添加技能
        </Button>
      </Form.Item>
    </>
  )}
</Form.List>
```

## 四、表单关联校验场景

### 1. 字段间依赖校验

**应用场景**：某个字段的校验规则依赖于其他字段的值，如确认密码、起止日期等。

**实现思路**：
- 使用 `dependencies` 属性声明依赖关系
- 在 `validator` 函数中通过 `getFieldValue` 获取依赖字段的值

```jsx
<Form.Item
  name="password"
  label="密码"
  rules={[{ required: true, message: '请输入密码！' }]}
>
  <Input.Password />
</Form.Item>

<Form.Item
  name="confirmPassword"
  label="确认密码"
  dependencies={['password']}
  rules={[
    { required: true, message: '请确认密码！' },
    ({ getFieldValue }) => ({
      validator(_, value) {
        if (!value || getFieldValue('password') === value) {
          return Promise.resolve();
        }
        return Promise.reject(new Error('两次输入的密码不一致！'));
      },
    }),
  ]}
>
  <Input.Password />
</Form.Item>
```

### 2. 条件校验

**应用场景**：根据某个字段的值决定其他字段是否必填或校验规则，如选择不同的支付方式需要填写不同的信息。

**实现思路**：
- 监听特定字段的变化
- 根据字段值动态设置其他字段的校验规则

```jsx
<Form.Item
  name="paymentMethod"
  label="支付方式"
  rules={[{ required: true, message: '请选择支付方式！' }]}
>
  <Select>
    <Option value="creditCard">信用卡</Option>
    <Option value="bankTransfer">银行转账</Option>
    <Option value="alipay">支付宝</Option>
  </Select>
</Form.Item>

<Form.Item
  noStyle
  shouldUpdate={(prevValues, currentValues) =>
    prevValues.paymentMethod !== currentValues.paymentMethod
  }
>
  {({ getFieldValue }) => {
    const paymentMethod = getFieldValue('paymentMethod');
    
    if (paymentMethod === 'creditCard') {
      return (
        <>
          <Form.Item
            name="cardNumber"
            label="卡号"
            rules={[{ required: true, message: '请输入信用卡号！' }]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="expiryDate"
            label="有效期"
            rules={[{ required: true, message: '请输入有效期！' }]}
          >
            <DatePicker picker="month" />
          </Form.Item>
          <Form.Item
            name="cvv"
            label="CVV"
            rules={[{ required: true, message: '请输入CVV码！' }]}
          >
            <Input maxLength={3} />
          </Form.Item>
        </>
      );
    }
    
    if (paymentMethod === 'bankTransfer') {
      return (
        <>
          <Form.Item
            name="accountName"
            label="账户名"
            rules={[{ required: true, message: '请输入账户名！' }]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="accountNumber"
            label="账号"
            rules={[{ required: true, message: '请输入账号！' }]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="bankName"
            label="银行名称"
            rules={[{ required: true, message: '请输入银行名称！' }]}
          >
            <Input />
          </Form.Item>
        </>
      );
    }
    
    if (paymentMethod === 'alipay') {
      return (
        <Form.Item
          name="alipayAccount"
          label="支付宝账号"
          rules={[{ required: true, message: '请输入支付宝账号！' }]}
        >
          <Input />
        </Form.Item>
      );
    }
    
    return null;
  }}
</Form.Item>
```

### 3. 联动校验

**应用场景**：多个字段之间存在联动关系，如省市区三级联动、商品数量和总价计算等。

**实现思路**：
- 使用 `shouldUpdate` 监听字段变化
- 使用 `setFieldsValue` 动态设置其他字段的值

```jsx
<Form.Item
  name="province"
  label="省份"
  rules={[{ required: true, message: '请选择省份！' }]}
>
  <Select
    placeholder="选择省份"
    onChange={() => {
      form.setFieldsValue({ city: undefined, district: undefined });
    }}
  >
    {/* 省份选项 */}
  </Select>
</Form.Item>

<Form.Item
  noStyle
  shouldUpdate={(prevValues, currentValues) =>
    prevValues.province !== currentValues.province
  }
>
  {({ getFieldValue }) => {
    const province = getFieldValue('province');
    return (
      <Form.Item
        name="city"
        label="城市"
        rules={[{ required: true, message: '请选择城市！' }]}
      >
        <Select
          placeholder="选择城市"
          disabled={!province}
          onChange={() => {
            form.setFieldsValue({ district: undefined });
          }}
        >
          {/* 根据省份显示对应的城市选项 */}
        </Select>
      </Form.Item>
    );
  }}
</Form.Item>

<Form.Item
  noStyle
  shouldUpdate={(prevValues, currentValues) =>
    prevValues.city !== currentValues.city
  }
>
  {({ getFieldValue }) => {
    const city = getFieldValue('city');
    return (
      <Form.Item
        name="district"
        label="区县"
        rules={[{ required: true, message: '请选择区县！' }]}
      >
        <Select placeholder="选择区县" disabled={!city}>
          {/* 根据城市显示对应的区县选项 */}
        </Select>
      </Form.Item>
    );
  }}
</Form.Item>
```

## 五、分步表单校验场景

### 1. 分步表单

**应用场景**：表单内容较多，需要分多个步骤填写，如注册流程、购买流程等。

**实现思路**：
- 结合 `Steps` 组件和 `Form` 组件
- 每个步骤对应一个表单或表单的一部分
- 在步骤切换时进行表单校验

```jsx
const [current, setCurrent] = useState(0);
const [form] = Form.useForm();

const steps = [
  { title: '基本信息' },
  { title: '联系方式' },
  { title: '其他信息' },
];

const next = async () => {
  try {
    // 根据当前步骤获取需要校验的字段
    let fieldsToValidate = [];
    if (current === 0) {
      fieldsToValidate = ['username', 'password', 'confirmPassword'];
    } else if (current === 1) {
      fieldsToValidate = ['email', 'phone', 'address'];
    }
    
    // 校验指定字段
    await form.validateFields(fieldsToValidate);
    setCurrent(current + 1);
  } catch (error) {
    console.log('校验失败:', error);
  }
};

const prev = () => {
  setCurrent(current - 1);
};

return (
  <>
    <Steps current={current}>
      {steps.map(item => (
        <Steps.Step key={item.title} title={item.title} />
      ))}
    </Steps>
    
    <Form form={form} layout="vertical">
      {current === 0 && (
        <>
          <Form.Item
            name="username"
            label="用户名"
            rules={[{ required: true, message: '请输入用户名！' }]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="password"
            label="密码"
            rules={[{ required: true, message: '请输入密码！' }]}
          >
            <Input.Password />
          </Form.Item>
          <Form.Item
            name="confirmPassword"
            label="确认密码"
            dependencies={['password']}
            rules={[
              { required: true, message: '请确认密码！' },
              ({ getFieldValue }) => ({
                validator(_, value) {
                  if (!value || getFieldValue('password') === value) {
                    return Promise.resolve();
                  }
                  return Promise.reject(new Error('两次输入的密码不一致！'));
                },
              }),
            ]}
          >
            <Input.Password />
          </Form.Item>
        </>
      )}
      
      {current === 1 && (
        <>
          <Form.Item
            name="email"
            label="邮箱"
            rules={[
              { required: true, message: '请输入邮箱！' },
              { type: 'email', message: '请输入有效的邮箱地址！' }
            ]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="phone"
            label="手机号"
            rules={[
              { required: true, message: '请输入手机号！' },
              { pattern: /^1[3-9]\d{9}$/, message: '请输入有效的手机号码！' }
            ]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="address"
            label="地址"
            rules={[{ required: true, message: '请输入地址！' }]}
          >
            <Input.TextArea />
          </Form.Item>
        </>
      )}
      
      {current === 2 && (
        <>
          <Form.Item
            name="occupation"
            label="职业"
          >
            <Input />
          </Form.Item>
          <Form.Item
            name="interests"
            label="兴趣爱好"
          >
            <Select mode="multiple" placeholder="选择兴趣爱好">
              <Option value="reading">阅读</Option>
              <Option value="sports">运动</Option>
              <Option value="music">音乐</Option>
              <Option value="travel">旅行</Option>
            </Select>
          </Form.Item>
          <Form.Item
            name="remark"
            label="备注"
          >
            <Input.TextArea />
          </Form.Item>
        </>
      )}
    </Form>
    
    <div style={{ marginTop: 24 }}>
      {current > 0 && (
        <Button style={{ marginRight: 8 }} onClick={prev}>
          上一步
        </Button>
      )}
      {current < steps.length - 1 && (
        <Button type="primary" onClick={next}>
          下一步
        </Button>
      )}
      {current === steps.length - 1 && (
        <Button type="primary" onClick={() => form.submit()}>
          提交
        </Button>
      )}
    </div>
  </>
);
```

### 2. 表单分组校验

**应用场景**：表单内容较多，需要分组展示和校验，如个人信息、工作信息、教育信息等。

**实现思路**：
- 使用 `Collapse` 或 `Tabs` 组件进行分组
- 对特定分组的字段进行校验

```jsx
const [form] = Form.useForm();

const validatePersonalInfo = async () => {
  try {
    await form.validateFields(['name', 'gender', 'birthday', 'idNumber']);
    message.success('个人信息校验通过！');
  } catch (error) {
    message.error('个人信息校验失败！');
  }
};

const validateWorkInfo = async () => {
  try {
    await form.validateFields(['company', 'position', 'salary', 'workYears']);
    message.success('工作信息校验通过！');
  } catch (error) {
    message.error('工作信息校验失败！');
  }
};

return (
  <Form form={form} layout="vertical">
    <Collapse defaultActiveKey={['1']}>
      <Collapse.Panel 
        header="个人信息" 
        key="1" 
        extra={<Button onClick={validatePersonalInfo}>校验</Button>}
      >
        <Form.Item
          name="name"
          label="姓名"
          rules={[{ required: true, message: '请输入姓名！' }]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          name="gender"
          label="性别"
          rules={[{ required: true, message: '请选择性别！' }]}
        >
          <Radio.Group>
            <Radio value="male">男</Radio>
            <Radio value="female">女</Radio>
          </Radio.Group>
        </Form.Item>
        <Form.Item
          name="birthday"
          label="出生日期"
          rules={[{ required: true, message: '请选择出生日期！' }]}
        >
          <DatePicker />
        </Form.Item>
        <Form.Item
          name="idNumber"
          label="身份证号"
          rules={[
            { required: true, message: '请输入身份证号！' },
            { pattern: /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/, message: '请输入有效的身份证号！' }
          ]}
        >
          <Input />
        </Form.Item>
      </Collapse.Panel>
      
      <Collapse.Panel 
        header="工作信息" 
        key="2"
        extra={<Button onClick={validateWorkInfo}>校验</Button>}
      >
        <Form.Item
          name="company"
          label="公司名称"
          rules={[{ required: true, message: '请输入公司名称！' }]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          name="position"
          label="职位"
          rules={[{ required: true, message: '请输入职位！' }]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          name="salary"
          label="薪资"
          rules={[
            { required: true, message: '请输入薪资！' },
            { type: 'number', min: 0, message: '薪资不能为负数！' }
          ]}
        >
          <InputNumber min={0} />
        </Form.Item>
        <Form.Item
          name="workYears"
          label="工作年限"
          rules={[
            { required: true, message: '请输入工作年限！' },
            { type: 'number', min: 0, message: '工作年限不能为负数！' }
          ]}
        >
          <InputNumber min={0} />
        </Form.Item>
      </Collapse.Panel>
    </Collapse>
    
    <Form.Item style={{ marginTop: 16 }}>
      <Button type="primary" htmlType="submit">
        提交
      </Button>
    </Form.Item>
  </Form>
);
```

## 六、高级表单校验场景

### 1. 异步校验

**应用场景**：需要通过API接口验证输入内容的有效性，如用户名是否已存在、验证码是否正确等。

**实现思路**：
- 在 `validator` 函数中发起异步请求
- 根据请求结果决定校验是否通过

```jsx
<Form.Item
  name="username"
  label="用户名"
  rules={[
    { required: true, message: '请输入用户名！' },
    {
      validator: async (_, value) => {
        if (!value) {
          return Promise.resolve();
        }
        
        // 模拟API请求
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            // 假设这些用户名已被占用
            const takenUsernames = ['admin', 'user', 'test'];
            if (takenUsernames.includes(value)) {
              reject(new Error('该用户名已被占用！'));
            } else {
              resolve();
            }
          }, 1000);
        });
      },
    },
  ]}
>
  <Input />
</Form.Item>
```

### 2. 全局表单校验

**应用场景**：需要对整个表单进行统一校验，如表单项之间的复杂关联关系、业务逻辑校验等。

**实现思路**：
- 在表单提交前进行自定义校验
- 获取所有表单值进行综合判断

```jsx
const [form] = Form.useForm();

const onFinish = async (values) => {
  // 自定义全局校验逻辑
  const { income, expense, balance } = values;
  
  if (income && expense && balance) {
    if (income - expense !== balance) {
      message.error('收入减去支出必须等于结余！');
      return;
    }
  }
  
  // 校验通过，提交表单
  console.log('表单提交成功:', values);
};

return (
  <Form form={form} onFinish={onFinish}>
    <Form.Item
      name="income"
      label="收入"
      rules={[
        { required: true, message: '请输入收入！' },
        { type: 'number', min: 0, message: '收入不能为负数！' }
      ]}
    >
      <InputNumber min={0} />
    </Form.Item>
    
    <Form.Item
      name="expense"
      label="支出"
      rules={[
        { required: true, message: '请输入支出！' },
        { type: 'number', min: 0, message: '支出不能为负数！' }
      ]}
    >
      <InputNumber min={0} />
    </Form.Item>
    
    <Form.Item
      name="balance"
      label="结余"
      rules={[
        { required: true, message: '请输入结余！' },
        { type: 'number', message: '结余必须是数字！' }
      ]}
    >
      <InputNumber />
    </Form.Item>
    
    <Form.Item>
      <Button type="primary" htmlType="submit">
        提交
      </Button>
    </Form.Item>
  </Form>
);
```

### 3. 动态规则校验

**应用场景**：根据用户操作或其他条件动态改变校验规则，如根据用户角色设置不同的必填项。

**实现思路**：
- 使用状态管理校验规则
- 根据条件动态设置规则

```jsx
const [userType, setUserType] = useState('individual');
const [form] = Form.useForm();

return (
  <Form form={form} layout="vertical">
    <Form.Item
      name="userType"
      label="用户类型"
      rules={[{ required: true, message: '请选择用户类型！' }]}
    >
      <Radio.Group onChange={(e) => setUserType(e.target.value)}>
        <Radio value="individual">个人用户</Radio>
        <Radio value="company">企业用户</Radio>
      </Radio.Group>
    </Form.Item>
    
    {userType === 'individual' ? (
      <>
        <Form.Item
          name="name"
          label="姓名"
          rules={[{ required: true, message: '请输入姓名！' }]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          name="idNumber"
          label="身份证号"
          rules={[
            { required: true, message: '请输入身份证号！' },
            { pattern: /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/, message: '请输入有效的身份证号！' }
          ]}
        >
          <Input />
        </Form.Item>
      </>
    ) : (
      <>
        <Form.Item
          name="companyName"
          label="公司名称"
          rules={[{ required: true, message: '请输入公司名称！' }]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          name="businessLicense"
          label="营业执照号"
          rules={[
            { required: true, message: '请输入营业执照号！' },
            { pattern: /^[0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/, message: '请输入有效的统一社会信用代码！' }
          ]}
        >
          <Input />
        </Form.Item>
        <Form.Item
          name="contactPerson"
          label="联系人"
          rules={[{ required: true, message: '请输入联系人！' }]}
        >
          <Input />
        </Form.Item>
      </>
    )}
    
    <Form.Item>
      <Button type="primary" htmlType="submit">
        提交
      </Button>
    </Form.Item>
  </Form>
);
```

## 七、特殊表单校验场景

### 1. 文件上传校验

**应用场景**：上传文件时需要校验文件类型、大小等，如上传头像、上传证件照等。

**实现思路**：
- 使用 `Upload` 组件的 `beforeUpload` 属性进行校验
- 结合表单校验规则进行必填校验

```jsx
const beforeUpload = (file) => {
  const isJpgOrPng = file.type === 'image/jpeg' || file.type === 'image/png';
  if (!isJpgOrPng) {
    message.error('只能上传JPG/PNG格式的图片！');
  }
  
  const isLt2M = file.size / 1024 / 1024 < 2;
  if (!isLt2M) {
    message.error('图片大小不能超过2MB！');
  }
  
  return isJpgOrPng && isLt2M;
};

const normFile = (e) => {
  if (Array.isArray(e)) {
    return e;
  }
  return e?.fileList;
};

<Form.Item
  name="avatar"
  label="头像"
  valuePropName="fileList"
  getValueFromEvent={normFile}
  rules={[{ required: true, message: '请上传头像！' }]}
>
  <Upload
    name="avatar"
    listType="picture-card"
    showUploadList={false}
    beforeUpload={beforeUpload}
    onChange={(info) => {
      if (info.file.status === 'done') {
        message.success('上传成功！');
      } else if (info.file.status === 'error') {
        message.error('上传失败！');
      }
    }}
  >
    {/* 上传按钮 */}
  </Upload>
</Form.Item>
```

### 2. 富文本编辑器校验

**应用场景**：使用富文本编辑器输入内容时需要进行校验，如文章发布、产品描述等。

**实现思路**：
- 将富文本编辑器与表单项关联
- 自定义校验函数处理富文本内容

```jsx
<Form.Item
  name="content"
  label="文章内容"
  rules={[
    { required: true, message: '请输入文章内容！' },
    {
      validator: (_, value) => {
        if (!value) {
          return Promise.resolve();
        }
        
        // 去除HTML标签后的纯文本
        const plainText = value.replace(/<[^>]+>/g, '');
        
        if (plainText.length < 50) {
          return Promise.reject(new Error('文章内容不能少于50个字符！'));
        }
        
        return Promise.resolve();
      },
    },
  ]}
>
  {/* 富文本编辑器组件 */}
</Form.Item>
```

### 3. 地图位置校验

**应用场景**：需要用户在地图上选择位置并进行校验，如店铺位置、配送地址等。

**实现思路**：
- 将地图组件与表单项关联
- 自定义校验函数处理地图位置数据

```jsx
<Form.Item
  name="location"
  label="店铺位置"
  rules={[
    { required: true, message: '请选择店铺位置！' },
    {
      validator: (_, value) => {
        if (!value) {
          return Promise.resolve();
        }
        
        const { latitude, longitude } = value;
        
        // 检查是否在服务范围内
        // 假设服务范围是北京市内
        const isInBeijing = latitude >= 39.4 && latitude <= 41.1 && longitude >= 115.7 && longitude <= 117.4;
        
        if (!isInBeijing) {
          return Promise.reject(new Error('店铺位置必须在北京市内！'));
        }
        
        return Promise.resolve();
      },
    },
  ]}
>
  {/* 地图选择组件 */}
</Form.Item>
```

## 八、表单性能优化场景

### 1. 大表单性能优化

**应用场景**：表单项较多，需要优化渲染性能，如复杂的配置表单、调查问卷等。

**实现思路**：
- 使用 `shouldUpdate` 控制表单项的重新渲染
- 将表单拆分为多个小组件
- 使用 `memo` 包装表单组件

```jsx
// 使用shouldUpdate优化渲染
<Form.Item
  noStyle
  shouldUpdate={(prevValues, currentValues) =>
    prevValues.category !== currentValues.category
  }
>
  {({ getFieldValue }) => {
    const category = getFieldValue('category');
    return category === 'product' ? (
      <ProductForm />
    ) : (
      <ServiceForm />
    );
  }}
</Form.Item>

// 将表单拆分为小组件
const ProductForm = React.memo(() => (
  <>
    <Form.Item
      name="productName"
      label="产品名称"
      rules={[{ required: true, message: '请输入产品名称！' }]}
    >
      <Input />
    </Form.Item>
    <Form.Item
      name="productPrice"
      label="产品价格"
      rules={[
        { required: true, message: '请输入产品价格！' },
        { type: 'number', min: 0, message: '价格不能为负数！' }
      ]}
    >
      <InputNumber min={0} />
    </Form.Item>
    {/* 其他产品相关表单项 */}
  </>
));

const ServiceForm = React.memo(() => (
  <>
    <Form.Item
      name="serviceName"
      label="服务名称"
      rules={[{ required: true, message: '请输入服务名称！' }]}
    >
      <Input />
    </Form.Item>
    <Form.Item
      name="servicePrice"
      label="服务价格"
      rules={[
        { required: true, message: '请输入服务价格！' },
        { type: 'number', min: 0, message: '价格不能为负数！' }
      ]}
    >
      <InputNumber min={0} />
    </Form.Item>
    {/* 其他服务相关表单项 */}
  </>
));
```

### 2. 按需校验

**应用场景**：只需要校验部分表单项，如保存草稿时只校验已填写的字段。

**实现思路**：
- 使用 `validateFields` 方法指定需要校验的字段
- 自定义校验逻辑处理特殊情况

```jsx
const [form] = Form.useForm();

const saveDraft = async () => {
  // 获取所有表单值，不进行校验
  const values = form.getFieldsValue();
  
  // 过滤出已填写的字段
  const filledFields = Object.entries(values)
    .filter(([_, value]) => value !== undefined && value !== '')
    .map(([field]) => field);
  
  if (filledFields.length === 0) {
    message.warning('请至少填写一项内容！');
    return;
  }
  
  try {
    // 只校验已填写的字段
    await form.validateFields(filledFields);
    console.log('保存草稿:', values);
    message.success('草稿保存成功！');
  } catch (error) {
    console.log('校验失败:', error);
  }
};

return (
  <Form form={form}>
    {/* 表单项 */}
    <Form.Item>
      <Button onClick={saveDraft}>保存草稿</Button>
      <Button type="primary" htmlType="submit" style={{ marginLeft: 8 }}>
        提交
      </Button>
    </Form.Item>
  </Form>
);
```

## 九、多语言表单校验场景

### 1. 多语言校验

**应用场景**：需要支持多种语言的表单校验，如国际化网站、多语言应用等。

**实现思路**：
- 结合 `i18n` 库实现校验信息的国际化
- 根据当前语言动态设置校验规则

```jsx
import { useTranslation } from 'react-i18next';

const { t, i18n } = useTranslation();
const currentLang = i18n.language;

// 根据语言设置不同的校验规则
const getPhoneRule = () => {
  if (currentLang === 'zh-CN') {
    // 中国大陆手机号格式
    return { pattern: /^1[3-9]\d{9}$/, message: t('validation.phone.format') };
  } else if (currentLang === 'en-US') {
    // 美国手机号格式
    return { pattern: /^\(\d{3}\) \d{3}-\d{4}$/, message: t('validation.phone.format') };
  }
  // 默认规则
  return { pattern: /^\d{5,15}$/, message: t('validation.phone.format') };
};

return (
  <Form>
    <Form.Item
      name="name"
      label={t('form.name')}
      rules={[{ required: true, message: t('validation.name.required') }]}
    >
      <Input />
    </Form.Item>
    
    <Form.Item
      name="phone"
      label={t('form.phone')}
      rules={[
        { required: true, message: t('validation.phone.required') },
        getPhoneRule(),
      ]}
    >
      <Input />
    </Form.Item>
    
    {/* 其他表单项 */}
  </Form>
);
```

## 十、无障碍表单校验场景

### 1. 无障碍校验提示

**应用场景**：需要支持屏幕阅读器等辅助技术，提供无障碍的表单校验体验。

**实现思路**：
- 使用 `aria-*` 属性增强表单的可访问性
- 提供清晰的错误提示和焦点管理

```jsx
const [form] = Form.useForm();
const [errors, setErrors] = useState({});

const onFinishFailed = ({ errorFields }) => {
  const newErrors = {};
  errorFields.forEach(({ name, errors }) => {
    newErrors[name[0]] = errors[0];
  });
  setErrors(newErrors);
  
  // 自动聚焦到第一个错误字段
  const firstErrorField = errorFields[0]?.name[0];
  if (firstErrorField) {
    form.getFieldInstance(firstErrorField)?.focus();
  }
};

return (
  <Form form={form} onFinishFailed={onFinishFailed}>
    <Form.Item
      name="username"
      label="用户名"
      rules={[{ required: true, message: '请输入用户名！' }]}
      aria-required="true"
      aria-invalid={errors.username ? 'true' : 'false'}
      aria-errormessage={errors.username ? 'username-error' : undefined}
    >
      <Input />
    </Form.Item>
    {errors.username && (
      <div id="username-error" role="alert" className="error-message">
        {errors.username}
      </div>
    )}
    
    {/* 其他表单项 */}
    
    <Form.Item>
      <Button type="primary" htmlType="submit">
        提交
      </Button>
    </Form.Item>
  </Form>
);
```

## 总结

本文档列举了多种表单校验业务场景及其实现思路，包括基础校验、嵌套表单校验、循环列表校验、表单关联校验、分步表单校验等。在实际开发中，可以根据具体需求选择合适的校验策略，也可以组合多种策略实现更复杂的表单校验功能。

表单校验是提升用户体验和数据质量的重要手段，合理的校验策略可以帮助用户更高效地完成表单填写，减少错误和挫折感。同时，良好的表单校验也能减轻服务端的数据处理负担，提高系统的整体性能和可靠性。